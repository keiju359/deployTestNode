
var fs = require('fs');
var path = require('path');

//
// This program is designed to be as unobtrusive as possible
// toward the config files that it will modify. It does so by
// creating a linemap. The linemap is used to preserve the 
// original structure of the file.
//

var sshconf = {};
module.exports = sshconf;

var cfgpath = path.join(process.env['HOME'], '.ssh/config');
var raw = [], hosts = {}, linemap = {};

//
// ### function path([path])
//
sshconf.path = function (p) {

  if (p) {
    cfgpath = p;
  }
  else {
    return cfgpath;
  }
};

//
// ### function write(value, callback)
//
sshconf.write = function (callback) {

  for (var host in hosts) {

    //
    // find out what line this host was originally on and rewrite the values.
    //
    raw[linemap[host].line] = 'Host ' + hosts[host].patterns.join(' ');

    //
    // find the properties in this host and write them to the correct line.
    //
    var thost = hosts[host].properties;
    var tlinemap = linemap[host].properties;

    for(var property in thost) {

      var linenum = tlinemap[property];
      var comment;
      
      //if (raw[linenum][0] !== '#') { 
        comment = raw[linenum].split('#')[1];
      //}

      raw[linenum] = property + ' ' + thost[property] + (comment ? ' #' + comment : '');
    }
  }

  fs.writeFile(cfgpath, raw.join('\n'), function (err) {
    return err ? callback(err) : callback();
  });
};

//
// ### function read(callback)
// #### callback {Function} what do when done.
// read and parse the ssh configuration file.
//
sshconf.read = function (callback) {

  raw = [];
  hosts = {};
  linemap = {};

  fs.readFile(cfgpath, function(err, data) {

    if (err) { 
      callback(err); 
    }
    else {

      raw = String(data).split('\n');
      var host;

      for (var i=0, l=raw.length; i<l; i++) {

        var line = raw[i].trim().split(' ');

        if (line[0].toLowerCase() === 'host') {

          var key = line[1];

          host = hosts[key] = {
            patterns: line,
            properties: {}
          };

          index = linemap[key] = {
            line: i,
            properties: {}
          };
        }

        if (host && line.length > 1 && raw[i][0] !== '#') {

          var key = line.splice(0, 1);
          var cleanline = line.join(' ').split('#')[0].trim();

          host.properties[key] = cleanline;
          index.properties[key] = i;
        } 
      }
      callback(null, hosts);
    }
  });
};

sshconf.remove = function() {

  if (arguments.length === 0) {
    hosts = {};
    linemap = {};
    raw = [];
  }
  else {

    var map = linemap[arguments[0]];
    raw.splice(map.line, 1);

    if (arguments.length === 2) {
      raw.splice(raw[map.properties[arguments[1]]], 1);
    }
    else {
      for (var ln in map.properties) {
        raw.splice(ln, 1);
      }
    }

    delete linemap[arguments[0]];
    delete hosts[arguments[0]];
  }
};

//
// ### function host([host], [data|key [value]]);
// #### host {String} the name of the host you want.
// #### data {Object} an entire config object to write.
// #### key {String} the key for one of the host's calues.
// #### value {String} the value for one of the host's keys.
// get or set vaues from the configuration.
//
sshconf.value = function () {

  if (arguments.length === 0) {
    return hosts;
  }
  else if (arguments.length === 1) {
    return hosts[arguments[0]];
  }
  else if (arguments.length === 2) {
    return hosts[arguments[0]].properties[arguments[1]];
  }
  else if (arguments.length === 3) {
    hosts[arguments[0]].properties[arguments[1]] = arguments[2];
    return sshconf;
  }
};
